## **РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
### **Факультет физико-математических и естественных наук**
### **Кафедра прикладной информатики и теории вероятностей**

---

**ОТЧЕТ
ПО ЛАБОРАТОРНОЙ РАБОТЕ № 13**

дисциплина: Операционные системы 

**Студент:** 

Афтаева Ксения Васильевна

**Преподаватель:** 

Велиева Т.В.

**Группа:** НПИбд-01-20

---

**МОСКВА**
2021 г.

### **Цель работы**: 

Изучить основы программирования в оболочке **ОС UNIX**. Научится писать более сложные командные файлы с использованием логических управляющих *конструкций* и *циклов*

### **Задачи**:

1. Изучить теоретический материал
2. Написать командный файл, реализующий упрощённый механизм семафоров. Командный файл должен в течение некоторого времени *t1* дожидаться освобождения ресурса, выдавая об этом сообщение, а дождавшись его освобождения, использовать его в течение некоторого времени *t2<>t1*, также выдавая информацию о том, что ресурс используется соответствующим командным файлом (процессом). Запустить командный файл в одном виртуальном терминале в фоновом режиме, перенаправив его вывод в другой, в котором также запущен этот файл, но не фоновом, а в привилегированном режиме. Доработать программу так, чтобы имелась возможность взаимодействия трёх и более процессов.
3. Реализовать команду ```man``` с помощью командного файла. Изучить содержимое
каталога **/usr/share/man/man1**. В нем находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд. Каждый архив можно открыть командой ```less``` сразу же просмотрев содержимое справки. Командный файл должен получать в виде аргумента командной строки название команды и в виде результата выдавать справку об этой команде или сообщение об отсутствии справки, если соответствующего файла нет в каталоге **man1**.
4. Используя встроенную  переменную  "$RANDOM",  написать  командный файл,  генерирующий случайную  последовательность   букв  латинского  алфавита. 
5. Ответить на контрольные вопросы. 

### **Объект и предмет исследования**:

Программирование в оболочке **OC UNIX/Linux**

### **Техническое оснащение**:

Ноутбук, на котором установлена виртуальная машина с Linux

### **Теоретические вводные данные** [[1]](https://eternalhost.net/blog/sistemnoe-administrirovanie/linux-bash-chto-eto) : 

**bash** (*сокр. от «Bourne-Again shell»*) — это командная оболочка (или «интерпретатор командной строки»), используемая по умолчанию в операционных системах на базе Unix и Linux, созданная в 1989 году Брайаном Фоксом с целью усовершенствования командной оболочки sh.

**bash** позволяет автоматизировать различные задачи, устанавливать программное обеспечение, настраивать конфигурации для своего рабочего окружения и многое другое.

 **Циклы BASH:**

Циклы позволяют выполнять один и тот же участок кода необходимое количество раз. В большинстве языков программирования существует несколько типов циклов. Большинство из них поддерживаются оболочкой Bash. 

 - for - позволяет перебрать все элементы из массива или использует переменную-счетчик для определения количества повторений;
 - while - цикл выполняется пока условие истинно;
 - until - цикл выполняется пока условие ложно.

 Bash позволяет использовать циклы как в скриптах, так и непосредственно в командной оболочке.

**Другие команды:**

 **flock** — утилита, которая позволяет использовать лок-файл для предотвращения запуска копии процесса (вашего скрипта, крона или чего-то еще). 

 **sleep**  – одна из самых простых команд. Как видно из названия, его единственная функция – спать. Другими словами, он вводит задержку на указанное время. 

 **$RANDOM** -  возвращает  псевдослучайные  целые  числа  в  диапазоне  0 - 32767. 

### **Условные обозначения и символы**: 

– $* — отображается вся командная строка или параметры оболочки;

– $? — код завершения последней выполненной команды;

– $$ — уникальный идентификатор процесса, в рамках которого выполняется командный процессор;

– $! — номер процесса, в рамках которого выполняется последняя вызванная на
выполнение в командном режиме команда;

– $- — значение флагов командного процессора;

– ${#*} — возвращает целое число — количество слов, которые были результатом $*;

– ${#name} — возвращает целое значение длины строки в переменной name;

– ${name[n]} — обращение к n-му элементу массива;

– ${name[*]} — перечисляет все элементы массива, разделённые пробелом;

– ${name[@]} — то же самое, но позволяет учитывать символы пробелы в самих переменных;

– ${name:-value} — если значение переменной name не определено, то оно будет заменено на указанное value;

– ${name:value} — проверяется факт существования переменной;

– ${name=value} — если name не определено, то ему присваивается значение value;

– ${name?value} — останавливает выполнение, если имя переменной не определено, и выводит value как сообщение об ошибке;

– ${name+value} — это выражение работает противоположно ${name-value}. Если переменная определена, то подставляется value;

– ${name#pattern} — представляет значение переменной name с удалённым самым коротким левым образцом (pattern);

– ${#name[*]} и ${#name[@]} — эти выражения возвращают количество элементов в массиве name.

---

### **Выполнение работы**:

**Задание 1**

1. Создала командный файл и открыла его на редактирование одной командой ```emacs lab13z1.sh```, где **emacs** - редактор, в котором я буду работать, а **lab13z1.sh** - название файла. В данном файле написала программу, выполняющую требуемые функции (Рис.1)

![](https://sun9-14.userapi.com/impg/GdWBd--vVjZSalKovxrRc4BKL-E3o_mApQshPQ/rOSSLiRiHlc.jpg?size=361x280&quality=96&sign=51770a8d64d9bb5faf55735ca5a38850&type=album)

*Рис.1 Программа к заданию 1*

Структура программы: в первой строке вызываем интерпритатор (в нашем случае **bash**). Далее мы присваиваем файлу номер, так как **flock** работает только с дескрипторами. Затем идем циклом, условием которого является **test -f ./lock.file**. Данное условие будет истинно, если файл существует и является именно файлом. Затем условием **if flock -n ${fn}**  мы проверяем, заблокирован ли файл (уже запущен). Если нет, то с ним можно работать. Тогда мы выводим информацию о том, что файл заблокирован, ждем 5 секунд (строка **sleep 5**), выводим информацию о том, что он разблокирован, ждем секунду.  Иначе выводим сообщение, что не можем с ним работать. 

После написания программы сохранила ее комбинацией клавиш ```C-x C-s``` и закрыла текстовый редактор. 

2. Таким образом, при запуске на нескольких терминалах данного файла (команда ```./lab13z1.sh```), терминалы будут "конфликтовать". Т.е если в одном терминале выводится "File was locked", в других будет выводиться строка "The file could not be locked". Если же выводится строка о разблокировке, то другие терминалы могут работаь с файлом. Я открыла 3 терминала и запустила в них файл (Рис.2)

![](https://sun9-58.userapi.com/impg/pBcqkALRjdtdnoJAk-SyN-df9oArcbWze1DoIg/Ouzj8Sa7n-g.jpg?size=394x364&quality=96&sign=d329a655b999220b85f32d3171ed4a8d&type=album)

*Рис.2 Работа файла задание 1*

Видим, что действительно есть "конфликт" . 

**Задание 2**

1. Создала командный файл и открыла его на редактирование одной командой ```emacs lab13z2.sh```, где **emacs** - редактор, в котором я буду работать, а **lab13z2.sh** - название файла. В данном файле написала программу, выполняющую требуемые функции (Рис.3)

![](https://sun9-76.userapi.com/impg/cju10NWl2UUdL0m77lJUWlOdRM73hea0FfU2Pg/X0l3sgev2uY.jpg?size=412x158&quality=96&sign=9e4c12479c9d5b72f3abaf6210af6341&type=album)

*Рис.3 Программа к заданию 2*

Структура программы: она состоит всего из 3 строк. 1 строка - вызов интерпритатора (в нашем случае **bash**). 2 строка - переход в каталог  **/usr/share/man/man1**, где находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд, которые мы будем просматривать. Переход был осуществен командой ```cd```.  Командой ```less``` просмотрим содержимое справки, используя указатель на файл.

После написания программы сохранила ее комбинацией клавиш ```C-x C-s``` и закрыла текстовый редактор. 

2. Даю право на выполнение этого файла, командой ```chmod +x lab13z2.sh```. Запускаю его, введя **./lab13z2.sh**, указав после него команду, справку о которой хочу увидеть - find (Рис.4)

![](https://sun9-56.userapi.com/impg/tj0wokWWtvwP0yWQLCyTmbqfJ4akEg-GcCj8mg/KaQv1g0MM_I.jpg?size=398x47&quality=96&sign=67af1f7767f5abef6af7e2666ecf779b&type=album)

*Рис.4 Запуск программы 2*

Видим, что у нас действительно вывелась справка о данной команде (Рис.5)

![](https://sun9-35.userapi.com/impg/_u8Xpf33NsrdX28LenRU8MZMYluPfpLl-bNn_Q/rIrRQwPyrFU.jpg?size=435x293&quality=96&sign=50573e694aebaa3e6d7c7cd7eb11ed97&type=album)

*Рис.5 Справка о команде find*

**Задание 3**

1. Создала командный файл и открыла его на редактирование одной командой ```emacs lab13z3.sh```, где **emacs** - редактор, в котором я буду работать, а **lab13z3.sh** - название файла. В данном файле написала программу, выполняющую требуемые функции (Рис.6)

![](https://sun9-10.userapi.com/impg/XpJU7VScr5pmZ0YjBCBKgp7XvgvN75c9aOEx9g/RZYO1dCcsbU.jpg?size=455x215&quality=96&sign=b7d9ea6166b58d4e6c45bbbd44833426&type=album)

*Рис.6 Программа к заданию 2*

Структура программы: в первой строке вызов интерпритатора (в нашем случае **bash**). Далее можно было обойтись последней строкой. Однако в таком случае, почти всегда были бы 5 значные строки (так как диапазон рандома до 32767 и пятизначных чисел значительно больше). Поэтому во второй строке я ввожу переменную **n**, куда помещаю рандомное число от 1 до 3. Далее я иду циклом от 1 до н. В каждой итерации я создаю рандомное число (**$RANDOM**), заменяю все цифры в нем на буквы (**tr '[0-9]' '[a-z]']) и вывожу на экран с помощью команды ```echo``` и опции -n, которая позволяет убрать переход на другую строку (слепляет их). Однако количество итераций не совпадает с количеством раз, которые изначально были запланированы. Это связано с тем, чтто в последнем выводе символов нужно убрать опцию, склеивающую строки. Поэтому в последней строке я делаю последний вывод без опции. 

После написания программы сохранила ее комбинацией клавиш ```C-x C-s``` и закрыла текстовый редактор. 

2. Запускаю программу несколько раз, вводя **./lab13z3.sh** (Рис.7)

![](https://sun9-42.userapi.com/impg/2WoFd8wveJYpSR3db-W_BD2b5E_hNI_XsTWxjQ/m5kEO8tbow0.jpg?size=401x77&quality=96&sign=07a6f583bbfd34e11d61b3361ac2a250&type=album)

*Рис.7 Результат программы 3*

Видим, что выводятся строки с рандомным набором букв и разной длиной. 

---

### **Контрольные вопросы**: 

1. Нужно взять в кавычки «$1» [[2]](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

2. Написать переменные одну за другой. Например: A = “$B$C” . Либо с помощью оператора +=. Например: B += C  [[3]](https://routerus.com/bash-concatenate-strings/)

3. Эта утилита выводит последовательность целых чисел с заданным шагом. Также можно реализовать с помощью утилиты jot. [[4]](https://www.opennet.ru/docs/RUS/bash_scripting_guide/x9307.html)

4. 3 

5. В zsh можно настроить отдельные сочетания клавиш так, как вам нравится. Использование истории команд в zsh ничем особенным не отличается от bash.  Zsh очень удобен для повседневной работы и делает добрую половину рутины за вас. Но стоит обратить внимание на различия между этими двумя оболочками. Например, в zsh после for обязательно вставлять пробел, нумерация массивов в zsh начинается с 1, чего совершенно невозможно понять. Так, если вы используете shell для повседневной работы, исключающей написание скриптов, используйте zsh. Если вам часто приходится писать свои скрипты, только bash! Впрочем, можно комбинировать. Как установить zsh в качестве оболочки по умолчанию для отдельного пользователя: о 

6. Синтаксис верен. [[2]](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

7. Преимущества: 

- По сравнению с cmd у bash больше возможностей. 

- По сравнению с нескриптовыми языками программирования у него более низкий порог вхождения.  

- Его не нужно отдельно устанавливать, он встроен в операционную систему.   

Недостатки:  

- В интернете меньше дополнительной информации про него, чем про языки программирования. 

- Сложнее отлаживать программу. 

---

### **Заключение**:

Теоретический материал изучен и пригодится в дальнейшей работе. Все цели и задачи выполнены.

### **Вывод**:

Я изучила основы программирования в оболочке **ОС UNIX**. Научилась писать более сложные командные файлы с использованием логических управляющих *конструкций* и *циклов*

---

### **Библиографический список**:

[1]: [Программирование в bash](https://eternalhost.net/blog/sistemnoe-administrirovanie/linux-bash-chto-eto)

[2]: [Описание лабораторной работы №11](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

[3]: [Команды bash](https://routerus.com/bash-concatenate-strings/)

[4]: [Команды jot, seq](https://www.opennet.ru/docs/RUS/bash_scripting_guide/x9307.html)