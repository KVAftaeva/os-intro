## **РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
### **Факультет физико-математических и естественных наук**
### **Кафедра прикладной информатики и теории вероятностей**

---

**ОТЧЕТ
ПО ЛАБОРАТОРНОЙ РАБОТЕ № 14**

дисциплина: Операционные системы 

**Студент:** 

Афтаева Ксения Васильевна

**Преподаватель:** 

Велиева Т.В.

**Группа:** НПИбд-01-20

---

**МОСКВА**
2021 г.

### **Цель работы**: 

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа *UNIX/Linux* на примере создания на языке программирования С **калькулятора с простейшими функциями**.

### **Задачи**:

1. Изучить теоретический материал
2. Выполнить пункты, указанные в описании к лабораторной работе (реализовать калькулятор и тд.)
5. Ответить на контрольные вопросы. 

### **Объект и предмет исследования**:

Программирование в оболочке **OC UNIX/Linux**

### **Техническое оснащение**:

Ноутбук, на котором установлена виртуальная машина с Linux

### **Теоретические вводные данные:** [[1]](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf) 

**Этапы разработки приложений**

Процесс разработки программного обеспечения обычно разделяется на следующие этапы:

- планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;
- проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования;
- непосредственная разработка приложения:
- кодирование — по сути создание исходного текста программы (возможно в нескольких вариантах);
- анализ разработанного кода;
- сборка, компиляция и разработка исполняемого модуля;
- тестирование и отладка, сохранение произведённых изменений;
- документирование.

Для создания исходного текста программы разработчик может воспользоваться любым удобным для него редактором текста: *vi, vim, mceditor, emacs, geany и др*.

После завершения написания исходного кода программы (возможно состоящей из нескольких файлов), необходимо её скомпилировать и получить исполняемый модуль.

**Компиляция исходного текста и построение исполняемого файла**

Стандартным средством для компиляции программ в ОС типа UNIX является **GCC** (*GNU Compiler Collection*). Это набор компиляторов для разного рода языков программирования (С, C++, Java, Фортран и др.). Работа с GCC производится при помощи одноимённой управляющей программы gcc, которая интерпретирует аргументы командной строки, определяет и осуществляет запуск нужного компилятора для входного файла. Файлы с расширением (суффиксом) .c воспринимаются gcc как программы на языке С, файлы с расширением .cc или .C — как файлы на языке C++, а файлы c расширением .o считаются объектными.

### **Условные обозначения и символы:**

Опции при компиляции:

- **-c** компиляция без компоновки — создаются объектные файлы file.o
- **-o** file-name задать имя file-name создаваемому файлу
- **-g** поместить в файл (объектный или исполняемый) отладочную информацию для отладчика gdb
- **-MM** вывести зависимости от заголовочных файлов C и/или C++ программ в формате, подходящем для утилиты make; при этом объектные или исполняемые файлы не будет созданы
- **-Wall** вывод на экран сообщений об ошибках, возникших во время компиляции

---

### **Выполнение работы**:

1. Создала подкаталог **lab_prog** в каталоге **~/work/os** с помощью команды ```mkdir```. Затем перешла в него, введя команду ```cd``` + полный путь к каталогу (Рис.1) 

![](https://sun9-51.userapi.com/impg/Zyh4Xeo40wN8IDZrdb-oHUn4Ilcwr6BV57iL-w/RtqG8w5KEw4.jpg?size=384x46&quality=96&sign=961c7924ab59c0b1a387aee38878b336&type=album)

*Рис.1 Переход в каталог для работы*

2. Создала в нём файлы **calculate.h**, **calculate.c**, **main.c** с помощью команды ```emacs``` (Текстовый редактор, в котором я буду работать). (Рис.2)

![](https://sun9-52.userapi.com/impg/3lQ042uoqTVn0ZMvdbRyDgLiucgOFALgtStrEg/HJW7T-gKIXc.jpg?size=402x49&quality=96&sign=5c86220dfcd7d9ac1fa3de0ceae8f242&type=album)

*Рис.2 Создание файлов*

Это будет примитивнейший калькулятор, способный складывать, вычитать, умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию, второе число. После этого программа выведет результат и остановится.

Реализация функций калькулятора в файле **calculate.c** (Рис.3-5)

![](https://sun9-51.userapi.com/impg/VRrj6HyP3C7Bf6Lpmn7Q4a7oG7TN9pmetCoZWQ/dFTk5MtrLlU.jpg?size=367x378&quality=96&sign=83244e164e0f008b9bf4d77a11532b29&type=album)

*Рис.3 calculate.c ч1*

![](https://sun9-9.userapi.com/impg/rKDz-ank_w947cNrOzuZEVZBctpiRfslz0mk6g/p_RYXBMCSX4.jpg?size=406x429&quality=96&sign=bfb7960fefa194ed252b87d630145abf&type=album)

*Рис.4 calculate.c ч2*

![](https://sun9-50.userapi.com/impg/Ih9vQKQ1lCdfLOmalwnrA3JhHzjJLXkDiA42Hw/Hl9JoGubb1E.jpg?size=391x201&quality=96&sign=adcc6e58fba8b113106410285a383f69&type=album)

*Рис.5 calculate.c ч3*

Интерфейсный файл **calculate.h**, описывающий формат вызова функции калькулятора (Рис.6)

![](https://sun9-28.userapi.com/impg/svmksjpZANMG6LtdpoUJJHzB38DDQ8n-6-JcJA/k7z9WDrxZIM.jpg?size=423x159&quality=96&sign=cc37a18e57d67c6a71160de5667a8057&type=album)

*Рис.6 calculate.h*

Основной файл **main.c**, реализующий интерфейс пользователя к калькулятору (Рис.7)

![](https://sun9-66.userapi.com/impg/44jLUeeOP_3hBq-RdGEEoea-LXnXlpIpqctlRQ/zEUFcxneR7g.jpg?size=398x302&quality=96&sign=bf445e521e6c6117f266a66c427e4745&type=album)

*Рис.7 main.c*

Данные программы были взяты из описания к лабораторной работе. После написания файлов я сохранила их комбинацией клавиш ```C-x C-s``` и закрыла. 

3. Выполнила компиляцию программы посредством gcc, добавив опцию **-g**, которая нужна для корректной работы с **gdb** (Рис.8)

![](https://sun9-5.userapi.com/impg/YijNJuFBD8coH_0PzUplLvnMhiXC3zNaG6RROw/xz8MU1axdiE.jpg?size=417x43&quality=96&sign=a4d055082b3248494004c2f61e6305fd&type=album)

*Рис.8 Компиляция программы*

4. Синтаксических ошибок не было выявлено

5. Создала  **Makefile** с помощью команды ```emacs``` (Рис.9)

![](https://sun9-38.userapi.com/impg/m0XOSvrIijFMdq8-r5Fli1aUpoSI8KUc3O38Jg/41pWYA35DZI.jpg?size=332x358&quality=96&sign=3bc6447b965284e9d8a704f2f97b68be&type=album)

*Рис.9 Makefile*

В этом файле мы создаем переменные CC, CFLAGS, LIBS. Инициализируем их.

Создаем блоки, в которых прописываем какие команды будут выполняться. При этом подставляя значение нами созданных переменных.

6. С помощью **gdb** выполнила отладку программы *calcul*:

- Запустила отладчик **GDB**, загрузив в него программу для отладки ```gdb ./calcul``` (Рис.10)

![](https://sun9-53.userapi.com/impg/2eEAMDN846eD3hewcpxenOTeUVqp0Bs9ni__Gw/bVbaD_GfX0k.jpg?size=405x123&quality=96&sign=2d7d6d3738cc9bfae94ce95790e71289&type=album)

*Рис.10 запуск отладчика*

Видим, что он был запущен и теперь мы работаем внутри него

- Для запуска программы внутри отладчика ввела команду ```run``` (Рис.11)

![](https://sun9-20.userapi.com/impg/SosZZHOFAGmfJ8LQOFPYB4QzbPmJZ4W5jl2Q4Q/Jk4_RxV7aXk.jpg?size=422x87&quality=96&sign=2845b1bbdb09335c9bdcb1ce3f16213d&type=album)

*Рис.11 запуск программы внутри отладчика*

Видим, что программа запрашивает первое число, операцию, второе число и успешно выводит результат

- Для постраничного (по 9 строк) просмотра исходного кода использовала команду ```list``` (Рис 12)
-  Для просмотра строк с 12 по 15 основного файла использовала ```list 12,15``` (Рис.12)
- Для просмотра определённых строк не основного файла использовала ```list calculate.c:20,29``` (Рис.12)

![](https://sun9-46.userapi.com/impg/gWdKD3iKpqjcp2AmPkycDjKu_xzAKVxeQvn02g/NeHO9-DCOqU.jpg?size=371x317&quality=96&sign=ef5c772db8d48bd780096c2b4ef0637f&type=album)

*Рис.12 Просмотр строк*

Видим, что выводятся нужные нам сроки нужных файлов

- Установила точку останова в файле *calculate.c* на строке номер 21 ```break 21``` (Рис.13)
- Вывела информацию об имеющихся в проекте точка останова ```info breakpoints``` (Рис.13)

![](https://sun9-46.userapi.com/impg/mwi5xpE5inGUErVSDjptlLefcG_A96IYItXQ6A/_koWh9CYYkM.jpg?size=424x58&quality=96&sign=423d0d5c4848bed65192db752c328e1c&type=album)

*Рис 13 Точки останова*

Видим, что точки останова были успешно установлены

- Запустила программу внутри отладчика и убедилась, что программа остановится в момент прохождения точки останова, введя построчно```run``` ```5``` ```-``` ```backtrace``` (Рис.14)

![](https://sun9-56.userapi.com/impg/1PeEoXLpQj3BS9wV1wL-QAC91WRWdW2BnBwRJw/lO16mAnxluc.jpg?size=428x99&quality=96&sign=5ae98bac2850dcc316f6142be9aa4d9f&type=album)

*Рис.14 Запуск программы с точкой останова*

Отладчик выдает следующую информацию:

"#0 Calculate (Numeral=5, Operation=0x7fffffffd280 "-")"

"at calculate.c:21"

"#1 0x0000000000400b2b in main () at main.c:17"

Команда backtrace показал весь стек вызываемых функций от начала программы до текущего места.

- Посмотрела, чему равно на этом этапе значение переменной Numeral, введя ```print Numeral``` (Рис. 15)

- Сравнилас результатом вывода на экран после использования команды ```display Numeral``` (Рис.15)

![](https://sun9-30.userapi.com/impg/RgzWdpMq-W4b3hngk-OBOjyH61Tt6N_IFodVnQ/DKyNhrPRRK4.jpg?size=345x115&quality=96&sign=7e083acfe6d7340a11d6bb7a6b93a8a6&type=album)

*Рис.15 Вывод значения переменной*

Оба раза выведено число 5

- Убрала точки останова ```delete 1``` (Рис.16)

![](https://sun9-58.userapi.com/impg/d46ou4CXFXlxRIvDjGoHRNEJQaXa7T66LULI4A/vUSBEBxo6cw.jpg?size=419x74&quality=96&sign=1af93763494ad8913c2589d95d0e8660&type=album)

*Рис.16 Удаление точки останова*

Вывела информацию о точках останова до и после удаления. Видим, что точка была удалена

7. С помощью утилиты **splint** проанализировала коды файлов *calculate.c и main.c.* (Рис.17-18)

![](https://sun9-18.userapi.com/impg/MSOs38PZOC_GL-Oy4dWlULPpWSFfBZnzYWwwpw/j7XoEDNfTIc.jpg?size=438x255&quality=96&sign=66f8baf6c4924ab3642d9dc933dd1774&type=album)

*Рис.17 Анализ с помощью утилиты splint 1*

![](https://sun9-3.userapi.com/impg/59FvK0fc05K_I6-dfNsJyZEnJ-hhb12PMPGJeQ/V-7LutUu8Ao.jpg?size=420x216&quality=96&sign=168bc14c0193dd47cf0dcbed2a32cdd3&type=album)

*Рис.18 Анализ с помощью утилиты splint 2*

Здесь мы можем увидеть что утилита splint выводит информацию о коде программы. Например то, что возвращаемое значение функции scanf() игнорируется 

---

### **Контрольные вопросы**: 

1. C помощью функций info и man. 

2. - создание исходного кода программы, которая представляется в виде файла 
   - сохранение различных вариантов исходного текста; 
   - анализ исходного текста; необходимо отслеживать изменения исходного кода, а также при работе более двух программистов над проектом программы нужно, чтобы они не делали изменений кода в одно время. 
   - компиляция исходного текста и построение исполняемого модуля; 
   - тестирование и отладка; 
   - проверка кода на наличие ошибок 
   - сохранение всех изменений, выполняемых при тестировании и отладке. [[1]](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf) 

3. Использование суффикса ".с" для имени файла с программой на языке Си отражает удобное и полезное соглашение, принятое в ОС UNIX. Для любого имени входного файла суффикс определяет какая компиляция требуется. Суффиксы и префиксы указывают тип объекта. Одно из полезных свойств компилятора Си — его способность по суффиксам определять типы файлов. По суффиксу .c компилятор распознает, что файл abcd.c должен компилироваться, а по суффиксу .o, что файл abcd.о является объектным модулем и для получения исполняемой программы необходимо выполнить редактирование связей. Простейший пример командной строки для компиляции программы abcd.c и построения исполняемого модуля abcd имеет вид: gcc -o abcd abcd.c. Некоторые проекты предпочитают показывать префиксы в начале текста изменений для старых (old) и новых (new) файлов. Опция – prefix может быть использована для установки такого префикса. Плюс к этому команда bzr diff -p1 выводит префиксы в форме которая подходит для команды patch -p1. [[1]](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf) 

4. Компиляция всей программы в целом и получении исполняемого модуля. 

5. Мake-файл содержит последовательность записей (строк), определяющих зависимости между файлами. Первая строка записи представляет собой список целевых (зависимых) файлов, разделенных пробелами, за которыми следует двоеточие и список файлов, от которых зависят целевые. [[1]](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf) 

6. Текст, следующий за точкой с запятой, и все последующие строки, начинающиеся с литеры табуляции, являются командами OC UNIX, которые необходимо выполнить для обновления целевого файла. Таким образом, спецификация взаимосвязей имеет формат: 

     target1 [ target2...]: [:] [dependment1...] 

     [(tab)commands] 

     [#commentary] 

     [(tab)commands] 

     [#commentary], 

   где # — специфицирует начало комментария, так как содержимое строки, начиная с # и до конца строки, не будет обрабатываться командой make; : — последовательность команд ОС UNIX должна содержаться в одной строке make-файла (файла описаний), есть возможность переноса команд (\), но она считается как одна строка; :: — последовательность команд ОС UNIX может содержаться в нескольких последовательных строках файла описаний. 

7. Пошаговая отладка программ заключается в том, что выполняется один оператор программы и, затем контролируются те переменные, на которые должен был воздействовать данный оператор. Если в программе имеются уже отлаженные подпрограммы, то подпрограмму можно рассматривать, как один оператор программы и воспользоваться вторым способом отладки программ. Если в программе существует достаточно большой участок программы, уже отлаженный ранее, то его можно выполнить, не контролируя переменные, на которые он воздействует. Использование точек останова позволяет пропускать уже отлаженную часть программы. Точка останова устанавливается в местах, где необходимо проверить содержимое переменных или просто проконтролировать, передаётся ли управление данному оператору. Практически во всех отладчиках поддерживается это свойство (а также выполнение программы до курсора и выход из подпрограммы). Затем отладка программы продолжается в пошаговом режиме с контролем локальных и глобальных переменных, а также внутренних регистров микроконтроллера и напряжений на выводах этой микросхемы. 

8. -  backtrace – выводит весь путь к текущей точке останова, то есть названия всех функций,начиная от main(); иными словами, выводит весь стек функций; 
   - break – устанавливает точку останова; параметром может быть номер строки или название функции; 
   - clear – удаляет все точки останова на текущем уровне стека (то есть в текущей функции); 
   - continue – продолжает выполнение программы от текущей точки до конца; 
   - delete – удаляет точку останова или контрольное выражение; 
   - display – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы; 
   - finish – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется; 
   - info breakpoints – выводит список всех имеющихся точек останова; 
   - info watchpoints – выводит список всех имеющихся контрольных выражений; 
   - list – выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки; 
   - next – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции; 
   - print – выводит значение какого-либо выражения (выражение передаётся в качестве параметра); 
   - run – запускает программу на выполнение; 
   - set – устанавливает новое значение переменной 
   - step – пошаговое выполнение программы; 
   - watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится; [[1]](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf) 

9. 1) Выполнили компиляцию программы  

   2) Увидели ошибки в программе  

   3) Открыли редактор и исправили программу  

   4) Загрузили программу в отладчик gdb  

   5) run — отладчик выполнил программу, мы ввели требуемые значения.  

   6) программа завершена, gdb не видит ошибок. 

10. Не возникло  

11. - cscope - исследование функций, содержащихся в программе; 
    - splint — критическая проверка программ, написанных на языке Си. 

12. 1) Проверка корректности задания аргументов всех использованных в программе функций, а также типов возвращаемых ими значений; 
    2) Поиск фрагментов исходного текста, корректных с точки зрения синтаксиса языка Си, но малоэффективных с точки зрения их реализации или содержащих в себе семантические ошибки; 
    3) Общая оценка мобильности пользовательской программы. [[2]](http://espressocode.top/splint-c-program-verifier/)

---

### **Заключение**:

Теоретический материал изучен и пригодится в дальнейшей работе. Все цели и задачи выполнены.

### **Вывод**:

Я приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа *UNIX/Linux* на примере создания на языке программирования С **калькулятора с простейшими функциями**.

---

### **Библиографический список**:

[1]: [Описание к лабораторной работе №14](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf)

[2]: [Splint - программа проверки АС](http://espressocode.top/splint-c-program-verifier/)
